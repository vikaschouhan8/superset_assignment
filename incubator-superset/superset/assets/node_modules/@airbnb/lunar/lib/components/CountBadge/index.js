"use strict";

exports.__esModule = true;
exports.default = exports.CountBadge = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _withStyles = _interopRequireDefault(require("../../composers/withStyles"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** A badge indicator with a count. */
class CountBadge extends _react.default.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "badgeRef", _react.default.createRef());
  }

  componentDidUpdate(prevProps) {
    const {
      value
    } = this.props;

    if (value && prevProps.value && value !== prevProps.value) {
      this.runPopAnimation();
    }
  }

  runPopAnimation() {
    if (this.badgeRef.current) {
      this.badgeRef.current.animate( // @ts-ignore Bug: https://github.com/Microsoft/TypeScript/issues/26073
      [{
        transform: 'scale(1)'
      }, {
        transform: 'scale(1.1)',
        offset: 0.3
      }, {
        transform: 'scale(.95)',
        offset: 0.8
      }, {
        transform: 'scale(1)'
      }], 300);
    }
  }

  render() {
    const {
      cx,
      accessibilityLabel,
      styles,
      value,
      waggle
    } = this.props;

    if (!value) {
      return null;
    }

    return _react.default.createElement("div", {
      className: cx(styles.badge, waggle ? styles.animateInAndWaggle : styles.animateIn),
      ref: this.badgeRef,
      "aria-label": accessibilityLabel
    }, value.toLocaleString());
  }

}

exports.CountBadge = CountBadge;

_defineProperty(CountBadge, "propTypes", {
  accessibilityLabel: _propTypes.default.string.isRequired,
  value: _propTypes.default.number.isRequired,
  waggle: _propTypes.default.bool
});

_defineProperty(CountBadge, "defaultProps", {
  waggle: false
});

var _default = (0, _withStyles.default)((_ref) => {
  let {
    color,
    font,
    unit
  } = _ref;
  const waggleDuration = 300;
  const totalDuration = 2000 + waggleDuration;
  const wagglePercent = waggleDuration / totalDuration * 100;
  const delayPercent = 100 - wagglePercent;
  const waggleFrames = {
    name: 'waggle',
    [delayPercent + "%"]: {
      transform: 'rotate(0deg)'
    },
    [wagglePercent * 0.3 + delayPercent + "%"]: {
      transform: 'rotate(25deg)'
    },
    [wagglePercent * 0.8 + delayPercent + "%"]: {
      transform: 'rotate(-10deg)'
    }
  };
  const inFrames = {
    name: 'animateIn',
    '0%': {
      transform: 'scale(0)',
      opacity: 0
    },
    '60%': {
      transform: 'scale(1.1)',
      opacity: 1
    },
    '80%': {
      transform: 'scale(.95)',
      opacity: 1
    },
    '100%': {
      transform: 'scale(1)',
      opacity: 1
    }
  };
  return {
    badge: _extends({}, font.textSmall, {
      backgroundColor: color.core.danger[6],
      color: color.base,
      textAlign: 'center',
      fontWeight: 'bold',
      padding: unit / 4,
      borderRadius: unit * 2,
      minWidth: unit * 4,
      boxSizing: 'border-box',
      display: 'inline-block'
    }),
    animateInAndWaggle: {
      animationDuration: "500ms, " + totalDuration + "ms",
      animationName: [inFrames, waggleFrames],
      animationIterationCount: '1, infinite',
      animationDelay: '0s, 500ms'
    },
    animateIn: {
      animationDuration: '500ms',
      animationName: inFrames
    }
  };
})(CountBadge);

exports.default = _default;