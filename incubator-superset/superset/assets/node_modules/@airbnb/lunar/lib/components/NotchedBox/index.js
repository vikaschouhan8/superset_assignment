"use strict";

exports.__esModule = true;
exports.default = exports.NotchedBox = exports.NOTCH_SPACING = exports.NOTCH_SIZE = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _withStyles = _interopRequireDefault(require("../../composers/withStyles"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function createPosition(offset) {
  if (typeof offset === 'number' && offset < 0) {
    return {
      right: Math.abs(offset)
    };
  }

  return {
    left: offset
  };
}

const NOTCH_SIZE = 1.5;
exports.NOTCH_SIZE = NOTCH_SIZE;
const NOTCH_SPACING = 1.5;
exports.NOTCH_SPACING = NOTCH_SPACING;

/** A container with a configurable arrow pointing outward. */
class NotchedBox extends _react.default.Component {
  render() {
    const {
      cx,
      styles,
      inverted,
      children,
      inline,
      notchBelow,
      notchOffset
    } = this.props;
    return _react.default.createElement("div", {
      className: cx(styles.box, !inverted && styles.border, inline && styles.box_inline)
    }, _react.default.createElement("div", {
      className: cx(styles.notch, notchOffset ? createPosition(notchOffset) : styles.notch_position, notchBelow && styles.notch_below, inverted ? styles.inverted : styles.border)
    }), _react.default.createElement("div", {
      className: cx(styles.content, inverted && styles.inverted)
    }, children));
  }

}

exports.NotchedBox = NotchedBox;

_defineProperty(NotchedBox, "propTypes", {
  children: _propTypes.default.any.isRequired,
  inline: _propTypes.default.bool,
  inverted: _propTypes.default.bool,
  notchBelow: _propTypes.default.bool,
  notchOffset: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])
});

_defineProperty(NotchedBox, "defaultProps", {
  inline: false,
  inverted: false
});

var _default = (0, _withStyles.default)((_ref) => {
  let {
    ui,
    color,
    unit
  } = _ref;
  const {
    border,
    borderRadius
  } = ui;
  const notchSide = NOTCH_SIZE * unit;
  const offset = -notchSide / 2;
  const left = unit + notchSide / Math.SQRT2;
  return {
    box: {
      position: 'relative',
      borderRadius
    },
    box_inline: {
      display: 'inline-block'
    },
    notch: {
      width: notchSide,
      height: notchSide,
      position: 'absolute',
      backgroundColor: color.core.neutral[0],
      transform: "translate(" + offset + "px, " + offset + "px) rotate(-45deg)"
    },
    notch_position: createPosition(left),
    notch_below: {
      bottom: -notchSide
    },
    border: {
      border
    },
    inverted: {
      borderColor: color.clear,
      backgroundColor: color.core.neutral[6]
    },
    content: {
      padding: NOTCH_SPACING * unit,
      position: 'relative',
      backgroundColor: color.core.neutral[0],
      borderRadius
    }
  };
})(NotchedBox);

exports.default = _default;