"use strict";

exports.__esModule = true;
exports.default = exports.Pagination = void 0;

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _airbnbPropTypes = require("airbnb-prop-types");

var _IconChevronLeft = _interopRequireDefault(require("@airbnb/lunar-icons/lib/interface/IconChevronLeft"));

var _IconChevronRight = _interopRequireDefault(require("@airbnb/lunar-icons/lib/interface/IconChevronRight"));

var _IconFirst = _interopRequireDefault(require("@airbnb/lunar-icons/lib/interface/IconFirst"));

var _IconLast = _interopRequireDefault(require("@airbnb/lunar-icons/lib/interface/IconLast"));

var _withStyles = _interopRequireDefault(require("../../composers/withStyles"));

var _IconButton = _interopRequireDefault(require("../IconButton"));

var _Text = _interopRequireDefault(require("../Text"));

var _Translate = _interopRequireDefault(require("../Translate"));

var _DirectionalIcon = _interopRequireDefault(require("../DirectionalIcon"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const alignProp = (0, _airbnbPropTypes.mutuallyExclusiveTrueProps)('centerAlign', 'endAlign', 'startAlign');

/** Pagination controls. */
class Pagination extends _react.default.Component {
  render() {
    const {
      cx,
      centerAlign,
      endAlign,
      fetching,
      hasNext,
      hasPrev,
      showBookends,
      startAlign,
      pageLabel = _Translate.default.phrase('Page', {}, {
        context: 'Label for pages',
        key: 'lunar.common.page'
      }),
      onFirst,
      onLast,
      onNext,
      onPrevious,
      page,
      pageCount,
      styles,
      theme
    } = this.props;

    if (!(hasNext || hasPrev)) {
      return null;
    }

    const previousPage = _react.default.createElement(_IconButton.default, {
      active: hasPrev,
      disabled: !hasPrev || fetching,
      onClick: onPrevious
    }, _react.default.createElement(_DirectionalIcon.default, {
      direction: "left",
      left: _IconChevronLeft.default,
      right: _IconChevronRight.default,
      accessibilityLabel: _Translate.default.phrase('Load previous page', {}, {
        context: 'Load previous page when paginating sets of data',
        key: 'lunar.pagination.loadPrevious'
      }),
      size: 4 * theme.unit
    }));

    const nextPage = _react.default.createElement(_IconButton.default, {
      active: hasNext,
      disabled: !hasNext || fetching,
      onClick: onNext
    }, _react.default.createElement(_DirectionalIcon.default, {
      direction: "right",
      left: _IconChevronLeft.default,
      right: _IconChevronRight.default,
      accessibilityLabel: _Translate.default.phrase('Load next page', {}, {
        context: 'Load next page when paginating sets of data',
        key: 'lunar.pagination.loadNext'
      }),
      size: 4 * theme.unit
    }));

    let firstPage = null;
    let lastPage = null;

    if (showBookends && typeof pageCount === 'number') {
      firstPage = _react.default.createElement(_IconButton.default, {
        active: hasPrev,
        disabled: page === 1 || fetching,
        onClick: onFirst
      }, _react.default.createElement(_DirectionalIcon.default, {
        direction: "left",
        left: _IconFirst.default,
        right: _IconLast.default,
        accessibilityLabel: _Translate.default.phrase('Load first page', {}, {
          context: 'Load first page when paginating sets of data',
          key: 'lunar.pagination.loadFirst'
        }),
        size: 4 * theme.unit
      }));
      lastPage = _react.default.createElement(_IconButton.default, {
        active: hasNext,
        disabled: pageCount < 2 || pageCount === page || fetching,
        onClick: onLast
      }, _react.default.createElement(_DirectionalIcon.default, {
        direction: "right",
        left: _IconFirst.default,
        right: _IconLast.default,
        accessibilityLabel: _Translate.default.phrase('Load last page', {}, {
          context: 'Load last page when paginating sets of data',
          key: 'lunar.pagination.loadLast'
        }),
        size: 4 * theme.unit
      }));
    }

    let paginationText = showBookends && pageCount ? _react.default.createElement(_Translate.default, {
      k: "lunar.pagination.pageCount",
      phrase: '%{pageNumber} of %{pageCount}',
      pageCount: pageCount,
      pageNumber: page,
      context: "Showing the current page number and total page count"
    }) : page;

    if (pageLabel) {
      paginationText = showBookends && pageCount ? _react.default.createElement(_Translate.default, {
        k: "lunar.pagination.pageCountLabeled",
        phrase: '%{pageLabel} %{pageNumber} of %{pageCount}',
        pageLabel: pageLabel,
        pageCount: pageCount,
        pageNumber: page,
        context: "Showing the current page number and total page count"
      }) : _react.default.createElement(_Translate.default, {
        k: "lunar.pagination.pageNumberLabeled",
        phrase: '%{pageLabel} %{pageNumber}',
        pageLabel: pageLabel,
        pageNumber: page,
        context: "Showing the current page number"
      });
    }

    return _react.default.createElement("div", {
      className: cx(styles.wrapper, endAlign && styles.wrapper_endAlign, centerAlign && styles.wrapper_centerAlign, startAlign && styles.wrapper_startAlign)
    }, _react.default.createElement("div", {
      className: cx(styles.previous)
    }, firstPage, previousPage), _react.default.createElement("div", {
      className: cx(styles.page)
    }, _react.default.createElement(_Text.default, {
      muted: true
    }, paginationText)), _react.default.createElement("div", {
      className: cx(styles.next)
    }, nextPage, lastPage));
  }

}

exports.Pagination = Pagination;

_defineProperty(Pagination, "defaultProps", {
  centerAlign: false,
  endAlign: false,
  fetching: false,
  hasNext: false,
  hasPrev: false,
  showBookends: false,
  startAlign: false
});

_defineProperty(Pagination, "propTypes", {
  onPrevious: _propTypes.default.func.isRequired,
  onNext: _propTypes.default.func.isRequired,
  pageLabel: _propTypes.default.string,
  page: _propTypes.default.number.isRequired,
  showBookends: _propTypes.default.bool,
  hasPrev: _propTypes.default.bool,
  hasNext: _propTypes.default.bool,
  fetching: _propTypes.default.bool,
  centerAlign: alignProp,
  endAlign: alignProp,
  startAlign: alignProp,
  onFirst: (0, _airbnbPropTypes.requiredBy)('showBookends', _propTypes.default.func),
  onLast: (0, _airbnbPropTypes.requiredBy)('showBookends', _propTypes.default.func),
  pageCount: (0, _airbnbPropTypes.requiredBy)('showBookends', _propTypes.default.number)
});

var _default = (0, _withStyles.default)((_ref) => {
  let {
    unit
  } = _ref;
  return {
    wrapper: {
      display: 'grid',
      gridTemplateAreas: '"previous page next"',
      gridTemplateColumns: 'auto 1fr auto',
      gridColumnGap: unit * 2,
      alignItems: 'center',
      justifyItems: 'center'
    },
    wrapper_endAlign: {
      gridTemplateAreas: '"page previous next"',
      gridTemplateColumns: 'auto',
      justifyContent: 'end'
    },
    wrapper_centerAlign: {
      gridTemplateColumns: 'auto',
      justifyContent: 'center'
    },
    wrapper_startAlign: {
      gridTemplateAreas: '"previous next page"',
      gridTemplateColumns: 'auto',
      justifyContent: 'start'
    },
    page: {
      gridArea: 'page'
    },
    previous: {
      gridArea: 'previous'
    },
    next: {
      gridArea: 'next'
    }
  };
}, {
  passThemeProp: true
})(Pagination);

exports.default = _default;