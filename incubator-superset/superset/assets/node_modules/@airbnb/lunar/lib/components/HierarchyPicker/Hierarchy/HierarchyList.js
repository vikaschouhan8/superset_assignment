"use strict";

exports.__esModule = true;
exports.default = exports.HierarchyList = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _Text = _interopRequireDefault(require("../../Text"));

var _withStyles = _interopRequireDefault(require("../../../composers/withStyles"));

var _HierarchyItem = _interopRequireDefault(require("./HierarchyItem"));

var _ItemDescription = _interopRequireDefault(require("./ItemDescription"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class HierarchyList extends _react.default.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "ref", _react.default.createRef());

    _defineProperty(this, "handleDomFocusDeeper", () => {
      const {
        verticallyAlign
      } = this.props;
      const li = this.closestRowToActiveElement();
      let deeper;

      if (verticallyAlign) {
        // next HierarchyList is a sibling
        const ul = li && li.parentElement;
        const parentDiv = ul && ul.parentElement;
        const nextMenu = parentDiv && parentDiv.nextElementSibling;
        deeper = nextMenu && nextMenu.querySelector('[tabindex]');
      } else {
        // next HierarchyList is a child
        const ul = li && li.lastElementChild;
        deeper = ul && ul.querySelector('[tabindex]');
      }

      if (deeper) {
        deeper.focus();
      }
    });

    _defineProperty(this, "handleDomFocusShallower", () => {
      const {
        verticallyAlign
      } = this.props;
      const li = this.closestRowToActiveElement();
      let shallower;

      if (verticallyAlign) {
        // prev HierarchyList is a sibling
        const ul = li && li.parentElement;
        const parentDiv = ul && ul.parentElement;
        const prevMenu = parentDiv && parentDiv.previousElementSibling; // focused parent tabIndex is higher than other parents

        shallower = prevMenu && prevMenu.querySelector('[tabindex="1"]');
      } else {
        // prev HierarchyList is a parent
        const parentLi = li && li.parentElement && li.parentElement.closest('li');
        shallower = parentLi && parentLi.querySelector('[tabindex]');
      }

      if (shallower) {
        shallower.focus();
      }
    });
  }

  isChosen(definition) {
    const {
      chosen
    } = this.props;
    return definition.every((name, i) => chosen[i] === name);
  }
  /** Returns the closest <li> to the current document activeElement */


  closestRowToActiveElement() {
    const {
      activeElement
    } = document;

    if (!activeElement || !activeElement.closest || !this.ref.current) {
      return null;
    }

    return activeElement.closest('li');
  }

  renderAside(item) {
    const {
      cx,
      styles,
      parents = [],
      onItemPicked,
      width,
      verticallyAlign
    } = this.props;

    if (item.items || !item.description) {
      return null;
    }

    return _react.default.createElement("aside", {
      className: cx(styles.pane, // descriptions are always nested
      styles.pane_nested, !verticallyAlign && styles.pane_verticallyOffset, styles.aside, {
        width
      })
    }, _react.default.createElement("button", {
      className: cx(styles.asideButton),
      onClick: () => onItemPicked([...parents, item.name]),
      tabIndex: -1,
      type: "button"
    }, _react.default.createElement(_ItemDescription.default, {
      item: item
    })));
  }

  render() {
    const _ref = this.props,
          {
      cx,
      focus,
      items,
      styles,
      parents,
      verticallyAlign
    } = _ref,
          passThruProps = _objectWithoutPropertiesLoose(_ref, ["cx", "focus", "items", "styles", "parents", "verticallyAlign"]);

    if (items.length === 0) {
      return null;
    }

    const [focusName, ...focusRest] = focus;
    const {
      maxHeight,
      width
    } = passThruProps;
    const isNested = parents.length > 0; // Track focused item to render as a sibling if vertically aligned

    let focusedItem;
    let currentSection;
    return _react.default.createElement(_react.default.Fragment, null, _react.default.createElement("div", {
      key: "list",
      className: cx(styles.pane, verticallyAlign && styles.pane_verticallyAlign, isNested && styles.pane_nested, isNested && !verticallyAlign && styles.pane_verticallyOffset, {
        width,
        maxHeight: verticallyAlign ? maxHeight : undefined,
        zIndex: 1
      }),
      ref: this.ref
    }, _react.default.createElement("ul", {
      className: cx(styles.list)
    }, items.map((item, index) => {
      const {
        name,
        section
      } = item;
      const definition = parents.concat(name);
      const isFocused = name === focusName;
      const shouldRenderSection = typeof section === 'string' && section !== currentSection;
      focusedItem = verticallyAlign && isFocused ? item : focusedItem;
      currentSection = shouldRenderSection ? section : currentSection;
      return _react.default.createElement(_react.default.Fragment, {
        key: item.name
      }, shouldRenderSection && index > 0 ? _react.default.createElement("li", {
        className: cx(styles.divider)
      }) : null, shouldRenderSection && section ? _react.default.createElement("li", {
        className: cx(styles.sectionHeader)
      }, _react.default.createElement(_Text.default, {
        small: true,
        bold: true,
        uppercased: true
      }, section)) : null, _react.default.createElement("li", {
        className: cx(styles.row)
      }, _react.default.createElement(_HierarchyItem.default, _extends({}, passThruProps, {
        onDomFocusDeeper: this.handleDomFocusDeeper,
        onDomFocusShallower: this.handleDomFocusShallower,
        item: item,
        definition: definition,
        selected: this.isChosen(definition),
        focused: isFocused
      })), !verticallyAlign && isFocused && item.items && item.items.length > 0 ? _react.default.createElement(HierarchyList, _extends({}, passThruProps, {
        cx: cx,
        styles: styles,
        items: item.items,
        focus: focusRest,
        parents: parents.concat(item.name),
        verticallyAlign: false
      })) : !verticallyAlign && isFocused && this.renderAside(item)));
    }))), verticallyAlign && focusedItem && focusedItem.items && focusedItem.items.length > 0 ? _react.default.createElement(HierarchyList, _extends({
      key: "sub-list"
    }, passThruProps, {
      cx: cx,
      styles: styles,
      items: focusedItem.items,
      focus: focusRest,
      parents: parents.concat(focusedItem.name),
      verticallyAlign: true
    })) : verticallyAlign && focusedItem && this.renderAside(focusedItem));
  }

}

exports.HierarchyList = HierarchyList;

_defineProperty(HierarchyList, "propTypes", {
  items: _propTypes.default.arrayOf(_propTypes.default.any),
  chosen: _propTypes.default.any,
  focus: _propTypes.default.any.isRequired,
  maxHeight: _propTypes.default.number,
  renderItem: _propTypes.default.any,
  parents: _propTypes.default.any,
  onSubtree: _propTypes.default.func.isRequired,
  onItemPicked: _propTypes.default.func.isRequired,
  width: _propTypes.default.number,
  verticallyAlign: _propTypes.default.bool
});

_defineProperty(HierarchyList, "defaultProps", {
  chosen: [],
  items: [],
  parents: [],
  verticallyAlign: false
});

var _default = (0, _withStyles.default)((_ref2) => {
  let {
    color,
    pattern,
    unit,
    ui
  } = _ref2;
  return {
    pane: {
      display: 'flex',
      borderRadius: ui.borderRadius
    },
    pane_verticallyAlign: {
      overflowY: 'auto',
      borderRadius: 0
    },
    pane_nested: {
      borderLeft: ui.border
    },
    pane_verticallyOffset: {
      position: 'absolute',
      overflow: 'visible',
      top: 0,
      marginLeft: -2,
      transform: 'translateX(100%)',
      background: color.accent.bg,
      border: ui.border,
      boxShadow: ui.boxShadowMedium
    },
    list: {
      flex: 1,
      listStyleType: 'none',
      padding: 0,
      margin: 0
    },
    sectionHeader: {
      padding: 1.5 * unit + "px " + 3 * unit + "px"
    },
    divider: {
      borderBottom: ui.border,
      marginTop: 0.5 * unit,
      marginBottom: 0.5 * unit
    },
    aside: {
      flex: 1,
      alignItems: 'flex-start',
      overflow: 'auto',
      wordBreak: 'break-word'
    },
    asideButton: _extends({}, pattern.resetButton, {
      flex: 1,
      padding: unit * 2,
      textAlign: 'left',
      cursor: 'help'
    }),
    row: {
      position: 'relative'
    }
  };
})(HierarchyList);

exports.default = _default;