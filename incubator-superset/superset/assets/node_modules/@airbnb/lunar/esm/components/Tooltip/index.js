import _pt from "prop-types";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable jsx-a11y/no-static-element-interactions */
import React from 'react';
import uuid from 'uuid/v4';
import Overlay from '../Overlay';
import NotchedBox, { NOTCH_SIZE, NOTCH_SPACING } from '../NotchedBox';
import Text from '../Text';
import withStyles from '../../composers/withStyles';
const EMPTY_TARGET_RECT = {
  bottom: 0,
  height: 0,
  left: 0,
  right: 0,
  top: 0,
  width: 0
};

/** A tooltip that renders in an portal, so it can escape potentially overflowed containers. */
export class Tooltip extends React.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      labelID: uuid(),
      open: false,
      tooltipHeight: 0,
      targetRect: EMPTY_TARGET_RECT
    });

    _defineProperty(this, "containerRef", React.createRef());

    _defineProperty(this, "currentTooltipRef", null);

    _defineProperty(this, "rafHandle", void 0);

    _defineProperty(this, "handleTooltipRef", ref => {
      this.currentTooltipRef = ref;
      this.updateTooltipHeight();
    });

    _defineProperty(this, "handleEnter", () => {
      const {
        current
      } = this.containerRef;
      /* istanbul ignore if: refs are hard */

      if (current) {
        this.setState({
          targetRect: current.getBoundingClientRect()
        });
      }

      if (!this.props.disabled && !this.state.open) {
        this.setState({
          open: true
        });
        this.props.onShow();
      }
    });

    _defineProperty(this, "handleMouseDown", () => {
      if (!this.props.remainOnMouseDown) {
        this.handleClose();
      }
    });

    _defineProperty(this, "handleClose", () => {
      this.setState({
        open: false
      });
    });
  }

  static getDerivedStateFromProps(_ref) {
    let {
      disabled
    } = _ref;

    if (disabled) {
      return {
        open: false
      };
    }

    return null;
  }

  componentDidMount() {
    // eslint-disable-next-line react/no-did-mount-set-state
    this.setState({
      targetRect: document.body.getBoundingClientRect()
    });
  }

  componentDidUpdate(prevProps) {
    if (prevProps.content !== this.props.content) {
      this.updateTooltipHeight();
    }
  }

  componentWillUnmount() {
    cancelAnimationFrame(this.rafHandle);
  }

  updateTooltipHeight() {
    // we need to know the height of the tooltip to position it above target

    /* istanbul ignore next: refs are hard */
    this.rafHandle = requestAnimationFrame(() => {
      const el = this.currentTooltipRef;
      this.setState({
        tooltipHeight: el ? el.offsetHeight : 0
      });
    });
  }

  bestPosition(rect) {
    const output = {
      above: false,
      align: 'left'
    };
    const {
      width: widthProp,
      theme
    } = this.props;
    /* istanbul ignore next: refs are hard */

    if (rect && widthProp && theme) {
      const {
        width: targetWidth,
        left,
        right,
        top
      } = rect;
      const {
        unit
      } = theme;
      const rightSpace = window.innerWidth - right;

      if (top > window.innerHeight * 0.6) {
        output.above = true;
      }

      if (Math.min(left, rightSpace) - unit > (widthProp * unit - targetWidth) / 2) {
        output.align = 'center';
      } else if (rightSpace < left) {
        output.align = 'right';
      }
    }

    return output;
  }

  render() {
    const {
      cx,
      styles,
      theme,
      width: widthProp,
      children,
      content,
      disabled,
      underlined,
      inverted
    } = this.props;
    const {
      open,
      targetRect,
      tooltipHeight,
      labelID
    } = this.state;
    const {
      unit
    } = theme;
    const width = widthProp * unit;
    const {
      align,
      above
    } = this.bestPosition(targetRect);
    const targetWidth = targetRect.width;
    const halfNotch = NOTCH_SIZE * unit / Math.SQRT2;
    const notchOffset = {
      center: '50%',
      right: -(unit * NOTCH_SPACING + halfNotch)
    };
    const marginLeft = {
      center: -width / 2 + targetWidth / 2,
      right: -width + targetWidth
    };
    const distance = halfNotch + 1;
    return React.createElement("span", {
      className: cx(styles.container),
      ref: this.containerRef
    }, React.createElement("div", {
      "aria-labelledby": labelID,
      onMouseEnter: this.handleEnter,
      onMouseLeave: this.handleClose,
      onMouseDown: this.handleMouseDown,
      className: cx(!disabled && underlined && styles.underlined)
    }, children), React.createElement("div", {
      id: labelID,
      className: cx(styles.offscreen)
    }, content), React.createElement(Overlay, {
      open: open,
      onClose: this.handleClose,
      noBackground: true
    }, React.createElement("div", {
      role: "tooltip",
      className: cx(styles.tooltip, above ? styles.tooltip_above : styles.tooltip_below, {
        width,
        marginLeft: marginLeft[align],
        marginTop: above ? -(tooltipHeight + targetRect.height + distance) : distance,
        textAlign: align
      }),
      ref: this.handleTooltipRef
    }, React.createElement("div", {
      className: cx(styles.shadow)
    }, React.createElement(NotchedBox, {
      inverted: !inverted,
      notchOffset: notchOffset[align],
      notchBelow: above
    }, React.createElement(Text, {
      inverted: !inverted
    }, content))))));
  }

}

_defineProperty(Tooltip, "propTypes", {
  width: _pt.number,
  content: _pt.any.isRequired,
  children: _pt.any.isRequired,
  disabled: _pt.bool,
  inverted: _pt.bool,
  remainOnMouseDown: _pt.bool,
  underlined: _pt.bool,
  onShow: _pt.func
});

_defineProperty(Tooltip, "defaultProps", {
  disabled: false,
  inverted: false,

  onShow() {},

  remainOnMouseDown: false,
  underlined: false,
  width: 35
});

export default withStyles((_ref2) => {
  let {
    unit,
    color,
    pattern,
    ui
  } = _ref2;
  return {
    container: {
      display: 'inline-block'
    },
    offscreen: _extends({}, pattern.offscreen),
    underlined: {
      borderBottom: "1px dotted " + color.core.primary[3],
      cursor: 'help'
    },
    tooltip: {
      animationDuration: '200ms',
      animationTimingFunction: 'ease-out'
    },
    tooltip_above: {
      animationName: {
        name: 'fadeDown',
        from: {
          opacity: 0,
          transform: "translateY(" + unit * 1.5 + "px)"
        },
        to: {
          opacity: 1
        }
      }
    },
    tooltip_below: {
      animationName: {
        name: 'fadeUp',
        from: {
          opacity: 0,
          transform: "translateY(-" + unit * 1.5 + "px)"
        },
        to: {
          opacity: 1
        }
      }
    },
    shadow: {
      display: 'inline-block',
      boxShadow: ui.boxShadowLarge,
      borderRadius: ui.borderRadius
    }
  };
}, {
  passThemeProp: true
})(Tooltip);