import _pt from "prop-types";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import debounce from 'lodash/debounce';
import throttle from 'lodash/throttle';
import IconChevronLeft from '@airbnb/lunar-icons/lib/interface/IconChevronLeft';
import IconChevronRight from '@airbnb/lunar-icons/lib/interface/IconChevronRight';
import withStyles from '../../composers/withStyles';
import DirectionalIcon from '../DirectionalIcon';
const INCREMENT = 25;

/** A horizontal scroller with gradients on each side. */
export class GradientScroller extends React.Component {
  constructor(props) {
    super(props); // Register resize observer before mounting

    _defineProperty(this, "contentsRef", null);

    _defineProperty(this, "observer", void 0);

    _defineProperty(this, "scrollInterval", 0);

    _defineProperty(this, "scrollerRef", null);

    _defineProperty(this, "state", {
      showStartGradient: false,
      showEndGradient: true
    });

    _defineProperty(this, "handleContentsRef", ref => {
      if (ref) {
        this.observer.observe(ref);
      } else if (this.contentsRef) {
        this.observer.unobserve(this.contentsRef);
      }

      this.contentsRef = ref;
    });

    _defineProperty(this, "handleScrollerRef", ref => {
      if (ref) {
        this.observer.observe(ref);
      } else if (this.scrollerRef) {
        this.observer.unobserve(this.scrollerRef);
      }

      this.scrollerRef = ref;
    });

    _defineProperty(this, "handleObserver", entries => {
      let calculate = false;
      entries.forEach((_ref) => {
        let {
          contentRect,
          target
        } = _ref;
        const width = target.dataset.prevWidth;
        const nextWidth = String(contentRect.width); // Dataset stores as strings

        if (!width || nextWidth !== width) {
          calculate = true; // eslint-disable-next-line no-param-reassign

          target.dataset.prevWidth = nextWidth;
        }
      });

      if (calculate) {
        this.handleResizeDebounced();
      }
    });

    _defineProperty(this, "handleResize", () => {
      this.calculate();
    });

    _defineProperty(this, "handleResizeDebounced", debounce(this.handleResize, 150));

    _defineProperty(this, "handleScroll", () => {
      const target = this.scrollerRef;
      const {
        showStartGradient,
        showEndGradient
      } = this.state;

      if (!target) {
        return;
      }

      if (target.scrollLeft > 0 && !showStartGradient) {
        this.setState({
          showStartGradient: true
        });
      } else if (target.scrollLeft === 0 && showStartGradient) {
        this.setState({
          showStartGradient: false
        });
      } // Get the largest width child to calculate against


      const scrolledWidth = target.scrollLeft + target.clientWidth;
      const maxChildWidth = this.calculateMaxChildWidth(target.children[0]);

      if (scrolledWidth < maxChildWidth && !showEndGradient) {
        this.setState({
          showEndGradient: true
        });
      } else if (scrolledWidth >= maxChildWidth && showEndGradient) {
        this.setState({
          showEndGradient: false
        });
      }
    });

    _defineProperty(this, "handleScrollThrottled", throttle(this.handleScroll, 100));

    _defineProperty(this, "handleScrollLeft", event => {
      this.doScroll(-this.calculateAutoScrollIncrement(), event.type !== 'click');
    });

    _defineProperty(this, "handleScrollRight", event => {
      this.doScroll(this.calculateAutoScrollIncrement(), event.type !== 'click');
    });

    _defineProperty(this, "handleScrollStop", () => {
      if (this.scrollInterval) {
        window.clearInterval(this.scrollInterval);
      }
    });

    this.observer = new window.ResizeObserver(this.handleObserver);
  }

  componentWillUnmount() {
    this.observer.disconnect();
  }

  calculate() {
    const scroller = this.scrollerRef;
    const contents = this.contentsRef;

    if (!scroller || !contents) {
      return;
    }

    const scrollerWidth = scroller.clientWidth;
    const maxChildWidth = this.calculateMaxChildWidth(contents);
    this.setState({
      showStartGradient: scroller.scrollLeft > 0,
      showEndGradient: maxChildWidth > scrollerWidth
    });
  }

  calculateAutoScrollIncrement() {
    let increment = this.props.autoScrollIncrement; // 15% of the width

    if (!increment && this.scrollerRef) {
      increment = this.scrollerRef.offsetWidth * 0.15;
    }

    if (!increment) {
      increment = INCREMENT;
    }

    return increment;
  }

  calculateMaxChildWidth(contents) {
    return Array.from(contents.children).reduce((width, child) => Math.max(child.clientWidth, width), contents.clientWidth);
  }

  doScroll(amount, interval) {
    if (interval === void 0) {
      interval = true;
    }

    const callback = () => {
      if (this.scrollerRef) {
        this.scrollerRef.scrollLeft += amount;
        this.handleScrollThrottled();
      }
    };

    this.handleScrollStop();

    if (interval) {
      this.scrollInterval = window.setInterval(callback, 100);
    } else {
      callback();
    }
  }

  render() {
    const {
      cx,
      children,
      styles,
      hideScrollbar,
      showArrows
    } = this.props;
    const {
      showStartGradient,
      showEndGradient
    } = this.state;
    return React.createElement("div", {
      className: cx(styles.container)
    }, React.createElement("div", {
      className: cx(styles.leftGradient, showStartGradient && styles.gradient_reveal)
    }, showArrows ? React.createElement("button", {
      className: cx(styles.leftArrow, hideScrollbar && styles.arrow_hideScrollbar),
      type: "button",
      onClick: this.handleScrollLeft
    }, React.createElement(DirectionalIcon, {
      direction: "left",
      left: IconChevronLeft,
      right: IconChevronRight,
      size: "2em",
      decorative: true
    })) : React.createElement("span", {
      className: cx(styles.scrollTrigger),
      onMouseEnter: this.handleScrollLeft,
      onMouseLeave: this.handleScrollStop
    })), React.createElement("div", {
      className: cx(styles.rightGradient, showEndGradient && styles.gradient_reveal)
    }, showArrows ? React.createElement("button", {
      className: cx(styles.rightArrow, hideScrollbar && styles.arrow_hideScrollbar),
      type: "button",
      onClick: this.handleScrollRight
    }, React.createElement(DirectionalIcon, {
      direction: "right",
      left: IconChevronLeft,
      right: IconChevronRight,
      size: "2em",
      decorative: true
    })) : React.createElement("span", {
      className: cx(styles.scrollTrigger),
      onMouseEnter: this.handleScrollRight,
      onMouseLeave: this.handleScrollStop
    })), React.createElement("div", {
      className: cx(styles.scroller, hideScrollbar && styles.scroller_hideScrollbar),
      ref: this.handleScrollerRef,
      onScroll: this.handleScrollThrottled
    }, React.createElement("div", {
      className: cx(styles.contents),
      ref: this.handleContentsRef
    }, children)));
  }

}

_defineProperty(GradientScroller, "propTypes", {
  autoScrollIncrement: _pt.number,
  children: _pt.node,
  hideScrollbar: _pt.bool,
  showArrows: _pt.bool
});

_defineProperty(GradientScroller, "defaultProps", {
  children: null,
  hideScrollbar: false,
  showArrows: false
});

export default withStyles((_ref2) => {
  let {
    color,
    unit,
    ui,
    pattern,
    transition
  } = _ref2;
  const scrollbarHeight = unit * 1.5;

  const gradient = _extends({}, transition.fade, {
    position: 'absolute',
    top: 0,
    bottom: 0,
    zIndex: 1,
    content: "''",
    opacity: 0,
    pointerEvents: 'none'
  });

  const arrow = _extends({}, pattern.resetButton, {
    position: 'absolute',
    top: '45%',
    marginTop: -scrollbarHeight / 2,
    transform: 'translateY(-50%)',
    backgroundColor: color.accent.bg,
    borderRadius: '50%',
    boxShadow: ui.boxShadow,
    padding: unit,
    outline: 'none',
    ':hover': {
      backgroundColor: color.accent.bgHover
    }
  });

  return {
    container: {
      width: '100%',
      position: 'relative',
      margin: -unit / 2
    },
    leftGradient: _extends({}, gradient, {
      width: unit * 5,
      left: 0,
      background: "linear-gradient(to right, " + color.accent.bg + " 40%, transparent 100%)"
    }),
    leftArrow: _extends({}, arrow, {
      left: -unit
    }),
    rightGradient: _extends({}, gradient, {
      width: unit * 5,
      right: 0,
      background: "linear-gradient(to left, " + color.accent.bg + " 40%, transparent 100%)"
    }),
    rightArrow: _extends({}, arrow, {
      right: -unit
    }),
    arrow_hideScrollbar: {
      top: '45%',
      marginTop: 0
    },
    gradient_reveal: {
      opacity: 1,
      pointerEvents: 'auto'
    },
    scroller: {
      overflowX: 'auto',
      overflowY: 'hidden',
      display: 'flex',
      alignItems: 'center',
      alignContent: 'stretch',
      paddingBottom: scrollbarHeight,
      '-webkit-overflow-scrolling': 'touch'
    },
    scroller_hideScrollbar: {
      paddingBottom: 0,
      '::-webkit-scrollbar': {
        display: 'none'
      }
    },
    scrollTrigger: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    },
    contents: {
      flexBasis: '100%',
      padding: unit / 2
    }
  };
})(GradientScroller);