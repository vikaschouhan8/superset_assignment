import _pt from "prop-types";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import { mutuallyExclusiveTrueProps, forbidExtraProps } from 'airbnb-prop-types';
import withStyles from '../../composers/withStyles';
const sizingProp = mutuallyExclusiveTrueProps('micro', 'small', 'large');
const emphasisProp = mutuallyExclusiveTrueProps('bold', 'light');
const stateProp = mutuallyExclusiveTrueProps('disabled', 'muted', 'inverted');
const alignProp = mutuallyExclusiveTrueProps('centerAlign', 'endAlign', 'startAlign');

/** Display a string of text with pre-defined sizing, emphasis, and state styling. */
export class Text extends React.Component {
  render() {
    const {
      cx,
      baseline,
      bold,
      centerAlign,
      children,
      disabled,
      endAlign,
      inline,
      inverted,
      large,
      light,
      micro,
      muted,
      noWrap,
      preserveWhitespace,
      small,
      startAlign,
      styles,
      truncated,
      uppercased
    } = this.props;
    let Tag = 'div';

    if (inline) {
      Tag = 'span';
    } else if (micro) {
      Tag = 'small';
    } else if (large) {
      Tag = 'h4';
    }

    return React.createElement(Tag, {
      className: cx(styles.text, bold && styles.text_bold, disabled && styles.text_disabled, inline && styles.text_inline, baseline && styles.text_baseline, inverted && styles.text_inverted, large && styles.text_large, light && styles.text_light, micro && styles.text_micro, muted && styles.text_muted, preserveWhitespace && styles.text_preserveWhitespace, small && styles.text_small, truncated && styles.text_truncated, uppercased && styles.text_uppercased, micro && uppercased && styles.text_uppercased_micro, centerAlign && styles.text_center, endAlign && styles.text_end, startAlign && styles.text_start, noWrap && styles.text_noWrap)
    }, children);
  }

}

_defineProperty(Text, "propTypes", {
  uppercased: _pt.bool,
  truncated: _pt.bool,
  preserveWhitespace: _pt.bool,
  noWrap: _pt.bool,
  inline: _pt.bool,
  children: _pt.node,
  baseline: _pt.bool,
  bold: emphasisProp,
  centerAlign: alignProp,
  disabled: stateProp,
  endAlign: alignProp,
  inverted: stateProp,
  large: sizingProp,
  light: emphasisProp,
  micro: sizingProp,
  muted: stateProp,
  small: sizingProp,
  startAlign: alignProp
});

_defineProperty(Text, "defaultProps", {
  baseline: false,
  bold: false,
  centerAlign: false,
  children: null,
  disabled: false,
  endAlign: false,
  inline: false,
  inverted: false,
  large: false,
  light: false,
  micro: false,
  muted: false,
  noWrap: false,
  preserveWhitespace: false,
  small: false,
  startAlign: false,
  truncated: false,
  uppercased: false
});

export default withStyles((_ref) => {
  let {
    color,
    font,
    pattern
  } = _ref;
  return {
    text: _extends({}, font.textReset, {}, font.textRegular, {
      color: color.accent.text
    }),
    text_baseline: {
      display: 'inline'
    },
    text_inline: {
      display: 'inline-block'
    },
    text_preserveWhitespace: {
      whiteSpace: 'pre-wrap'
    },
    text_micro: _extends({}, font.textMicro),
    text_small: _extends({}, font.textSmall),
    text_large: _extends({}, font.textLarge),
    text_disabled: _extends({}, pattern.disabled),
    text_inverted: {
      color: color.base
    },
    text_muted: {
      color: color.muted
    },
    text_bold: {
      fontWeight: font.weights.semibold
    },
    text_light: {
      fontWeight: font.weights.light
    },
    text_truncated: {
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap',
      '@selectors': {
        '> div': {
          display: 'inline'
        }
      }
    },
    text_uppercased: {
      textTransform: 'uppercase'
    },
    text_uppercased_micro: {
      letterSpacing: 1
    },
    text_center: {
      textAlign: 'center'
    },
    text_end: {
      textAlign: 'right'
    },
    text_start: {
      textAlign: 'left'
    },
    text_noWrap: {
      whiteSpace: 'nowrap'
    }
  };
})(Text);