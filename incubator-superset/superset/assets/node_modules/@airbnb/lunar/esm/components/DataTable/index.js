function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import { AutoSizer, SortDirection, Table } from 'react-virtualized';
import memoize from 'lodash/memoize';
import sortData from './helpers/sortData';
import expandData from './helpers/expandData';
import { indexData } from './helpers/indexData';
import ColumnLabels from './ColumnLabels';
import TableHeader from './TableHeader';
import renderDataColumns from './columns/renderDataColumns';
import renderExpandableColumn from './columns/renderExpandableColumn';
import renderSelectableColumn from './columns/renderSelectableColumn';
import withStyles from '../../composers/withStyles';
import { getRowColor, getHeight, getKeys } from './helpers';
import { HEIGHT_TO_PX, SELECTION_OPTIONS } from './constants';
export * from './types';

/** A dynamic and responsive table for displaying tabular data. */
export class DataTable extends React.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      changeLog: {},
      expandedRows: new Set(),
      selectedRows: {},
      sortBy: this.props.sortByOverride || '',
      sortDirection: this.props.sortDirectionOverride,
      editMode: false
    });

    _defineProperty(this, "keys", getKeys(this.props.keys, this.props.data));

    _defineProperty(this, "getRowStyle", expandedDataList => (_ref) => {
      let {
        index
      } = _ref;
      return {
        background: getRowColor(expandedDataList[index], index, this.props.zebra || false, this.props.theme),
        display: 'flex',
        flexDirection: 'row',
        alignItems: 'center',
        borderBottom: this.props.showRowDividers ? '1px solid' : '',
        borderColor: this.props.theme.color.core.neutral[1],
        outline: 'none'
      };
    });

    _defineProperty(this, "getData", memoize((data, sortBy, sortDirection, selectedRows) => {
      const {
        selectedRowsFirst
      } = this.props;
      const indexedData = indexData(data);
      const sortedData = sortData(indexedData, this.keys, selectedRows, selectedRowsFirst, sortBy, sortDirection);
      return sortedData;
    }, function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return JSON.stringify(args);
    }));

    _defineProperty(this, "getTableHeight", expandedDataList => {
      const {
        height,
        rowHeight,
        showAllRows
      } = this.props;
      return showAllRows ? expandedDataList.length * getHeight(rowHeight) + this.getColumnHeaderHeight() : height || 0;
    });

    _defineProperty(this, "getColumnHeaderHeight", () => {
      const {
        columnHeaderHeight,
        rowHeight
      } = this.props;
      return getHeight(rowHeight, columnHeaderHeight);
    });

    _defineProperty(this, "shouldRenderTableHeader", () => {
      const {
        editable,
        extraHeaderButtons,
        tableHeaderLabel
      } = this.props;
      return editable || extraHeaderButtons.length > 0 || !!tableHeaderLabel;
    });

    _defineProperty(this, "sort", (_ref2) => {
      let {
        sortBy,
        sortDirection
      } = _ref2;
      const {
        sortOverride,
        sortCallback
      } = this.props;

      if (sortOverride && sortCallback) {
        sortCallback(sortBy, sortDirection);
      } else {
        this.setState({
          sortBy,
          sortDirection
        });
      }
    });

    _defineProperty(this, "expandRow", newExpandedRowIndex => event => {
      event.stopPropagation();
      this.setState((_ref3) => {
        let {
          expandedRows
        } = _ref3;
        const newExpandedRows = new Set(expandedRows);

        if (expandedRows.has(newExpandedRowIndex)) {
          newExpandedRows.delete(newExpandedRowIndex);
        } else {
          newExpandedRows.add(newExpandedRowIndex);
        }

        return {
          expandedRows: newExpandedRows
        };
      });
    });

    _defineProperty(this, "onEdit", (row, key, newVal, event) => {
      const {
        defaultEditCallback,
        editCallbacks,
        instantEdit
      } = this.props;

      if (defaultEditCallback) {
        defaultEditCallback(row, key, newVal, event);
      }

      if (editCallbacks && editCallbacks[key]) {
        editCallbacks[key](row, key, newVal, event);
      }

      if (!instantEdit) {
        const {
          changeLog
        } = this.state;
        const {
          originalIndex
        } = row.rowData.metadata;

        if (Object.prototype.hasOwnProperty.call(changeLog, originalIndex)) {
          changeLog[originalIndex][key] = newVal;
        } else {
          changeLog[originalIndex] = {
            [key]: newVal
          };
        }

        this.setState({
          changeLog
        });
      }
    });

    _defineProperty(this, "handleDisableEditMode", () => {
      this.setState({
        editMode: false
      });
    });

    _defineProperty(this, "handleEnactEdits", () => {
      const {
        enactEditsCallback
      } = this.props;
      const {
        changeLog
      } = this.state;
      this.setState({
        editMode: false
      });

      if (enactEditsCallback) {
        enactEditsCallback(changeLog);
      }
    });

    _defineProperty(this, "handleEnableEditMode", () => {
      this.setState({
        editMode: true
      });
    });

    _defineProperty(this, "handleChildSelection", row => {
      const {
        data,
        selectCallback
      } = this.props;
      const {
        selectedRows,
        sortBy,
        sortDirection
      } = this.state;
      const sortedData = this.getData(data, sortBy, sortDirection, selectedRows);
      const {
        parentOriginalIndex,
        parentIndex,
        originalIndex
      } = row.metadata; // If parent is already selected

      if (Object.prototype.hasOwnProperty.call(selectedRows, parentOriginalIndex)) {
        const {
          selectedChildren
        } = selectedRows[parentOriginalIndex]; // If child is already selected

        if (selectedChildren.has(originalIndex)) {
          selectedChildren.delete(originalIndex); // If there are now 0 selected children

          if (selectedChildren.size === 0) {
            delete selectedRows[parentOriginalIndex]; // If there is still at least one selected child
          } else {
            selectedRows[parentOriginalIndex].status = SELECTION_OPTIONS.HAS_ACTIVE_CHILD;
          } // If child is not already selected

        } else {
          selectedChildren.add(originalIndex); // If all children are now selected

          if (sortedData[parentIndex].metadata.children.length === selectedChildren.size) {
            selectedRows[parentOriginalIndex].status = SELECTION_OPTIONS.ACTIVE; // If not all children are now selected
          } else {
            selectedRows[parentOriginalIndex].status = SELECTION_OPTIONS.HAS_ACTIVE_CHILD;
          }
        } // If parent is not already selected

      } else {
        selectedRows[parentOriginalIndex] = {
          status: SELECTION_OPTIONS.HAS_ACTIVE_CHILD,
          selectedChildren: new Set([originalIndex])
        };
      }

      this.setState({
        selectedRows
      }, selectCallback(row, selectedRows));
    });

    _defineProperty(this, "handleSelection", rowData => () => {
      if (rowData.metadata.isChild) {
        this.handleChildSelection(rowData);
      } else {
        this.handleParentSelection(rowData);
      }
    });

    _defineProperty(this, "handleRowClick", (_ref4) => {
      let {
        rowData
      } = _ref4;
      return this.props.selectOnRowClick && this.handleSelection(rowData)();
    });

    _defineProperty(this, "rowGetter", expandedDataList => (_ref5) => {
      let {
        index
      } = _ref5;
      return expandedDataList[index];
    });
  }

  componentDidUpdate(prevProps) {
    if (this.props.data !== prevProps.data) {
      this.keys = getKeys(this.props.keys, this.props.data);
      this.setState({
        selectedRows: {},
        expandedRows: new Set()
      });
    }
  }

  handleParentSelection(row) {
    const {
      selectedRows
    } = this.state;
    const {
      selectCallback
    } = this.props;
    const {
      originalIndex
    } = row.metadata; // If parent is already selected

    if (Object.prototype.hasOwnProperty.call(selectedRows, originalIndex)) {
      delete selectedRows[originalIndex]; // If parent is not already selected
    } else {
      // Is there are children, select them all
      const children = row.metadata.children ? row.metadata.children.map(child => child.metadata.originalIndex) : [];
      selectedRows[originalIndex] = {
        status: SELECTION_OPTIONS.ACTIVE,
        selectedChildren: new Set(children)
      };
    }

    this.setState({
      selectedRows
    }, selectCallback(row, selectedRows));
  }

  renderTableHeader(parentWidth) {
    const {
      editable,
      extraHeaderButtons,
      instantEdit,
      rowHeight,
      tableHeaderLabel,
      tableHeaderHeight
    } = this.props;
    const {
      editMode,
      selectedRows
    } = this.state;
    return React.createElement(TableHeader, {
      editable: editable,
      editMode: editMode,
      onEnactEdits: this.handleEnactEdits,
      onEnableEditMode: this.handleEnableEditMode,
      onDisableEditMode: this.handleDisableEditMode,
      extraHeaderButtons: extraHeaderButtons,
      height: getHeight(rowHeight, tableHeaderHeight),
      instantEdit: instantEdit,
      selectedRows: selectedRows,
      tableHeaderLabel: tableHeaderLabel,
      width: this.props.width ? Math.min(this.props.width, parentWidth) : parentWidth
    });
  }

  render() {
    const {
      cx,
      data,
      expandable,
      filterData,
      propagateRef,
      rowHeight,
      selectable,
      styles,
      selectedRowsFirst
    } = this.props;
    const {
      expandedRows,
      sortBy,
      sortDirection,
      editMode,
      selectedRows
    } = this.state;
    const sortedData = this.getData(data, sortBy, sortDirection, selectedRows);
    const filteredData = filterData(sortedData);
    const expandedData = expandData(filteredData, expandedRows, selectedRows, selectedRowsFirst, sortBy, this.keys, sortDirection);
    return React.createElement("div", null, this.shouldRenderTableHeader() && React.createElement(AutoSizer, {
      disableHeight: true
    }, (_ref6) => {
      let {
        width
      } = _ref6;
      return this.renderTableHeader(width);
    }), React.createElement("div", {
      className: cx(styles.table_container)
    }, React.createElement(AutoSizer, {
      disableHeight: true
    }, (_ref7) => {
      let {
        width
      } = _ref7;
      return React.createElement(Table, {
        height: this.getTableHeight(expandedData),
        width: this.props.width || width,
        headerHeight: this.getColumnHeaderHeight(),
        ref: propagateRef,
        rowCount: expandedData.length,
        rowHeight: HEIGHT_TO_PX[rowHeight],
        rowGetter: this.rowGetter(expandedData),
        rowStyle: this.getRowStyle(expandedData),
        sort: this.sort,
        sortBy: sortBy,
        sortDirection: sortDirection,
        headerRowRenderer: ColumnLabels(this.props),
        onRowClick: this.handleRowClick
      }, expandable && renderExpandableColumn(cx, styles, expandedRows, this.expandRow), selectable && renderSelectableColumn(selectedRows, this.handleSelection, expandable), renderDataColumns(this.keys, editMode, this.onEdit, this.props));
    })));
  }

}

_defineProperty(DataTable, "defaultProps", {
  columnHeaderHeight: undefined,
  columnLabelCase: '',
  columnMetadata: {},
  columnToLabel: {},
  data: [],
  defaultEditCallback: () => {},
  editable: false,
  editCallbacks: {},
  enactEditsCallback: () => {},
  expandable: false,
  extraHeaderButtons: [],
  filterData: data => data,
  height: 400,
  instantEdit: true,
  keys: [],
  renderers: {},
  rowHeight: 'regular',
  selectable: false,
  selectCallback: (rowData, selectedRows) => () => {},
  selectedRowsFirst: false,
  selectOnRowClick: false,
  showAllRows: false,
  showColumnDividers: false,
  showRowDividers: false,
  sortByOverride: '',
  sortCallback: () => {},
  sortDirectionOverride: SortDirection.ASC,
  sortOverride: false,
  tableHeaderHeight: undefined,
  tableHeaderLabel: '',
  width: 0,
  zebra: false
});

export default withStyles((_ref8) => {
  let {
    ui
  } = _ref8;
  return {
    table_container: {
      overflowX: 'auto'
    },
    column_header: {
      borderBottom: ui.border,
      cursor: 'pointer'
    },
    column: {
      height: 'inherit'
    },
    column_divider: {
      borderRight: ui.border
    },
    row: {
      height: '100%',
      display: 'flex',
      alignItems: 'center'
    },
    row_inner: {
      width: '100%'
    },
    expand_caret: {
      cursor: 'pointer'
    }
  };
}, {
  passThemeProp: true
})(DataTable);