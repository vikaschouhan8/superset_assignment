import _pt from "prop-types";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import { mutuallyExclusiveTrueProps, forbidExtraProps } from 'airbnb-prop-types';
import withStyles from '../../composers/withStyles';
import removeFocusOnMouseUp from '../../utils/removeFocusOnMouseUp';
import ProfilePhoto from '../ProfilePhoto';
import Shimmer from '../Shimmer';
import Text from '../Text';
import Spacing from '../Spacing';
import T from '../Translate';
import toRGBA from '../../utils/toRGBA'; // add color flags here

const stripeColorTypePropType = mutuallyExclusiveTrueProps('important', 'info', 'warning');

/** An individual comment within a message thread. */
export class MessageItem extends React.Component {
  render() {
    const {
      cx,
      children,
      disableTitleTranslation,
      email,
      formattedTimestamp,
      horizontalSpacing,
      icon,
      imageBadgeSrc,
      imageDescription,
      imageSrc,
      important,
      info,
      loadingAuthor,
      onClickImage,
      onClickTitle,
      sending,
      source,
      styles,
      title,
      titleClickDescription,
      titleTag,
      verticalSpacing,
      warning
    } = this.props;
    const timestamp = source ? T.phrase('%{time} via %{source}', {
      time: formattedTimestamp,
      source
    }, {
      context: 'Timestamp and source within a message bubble',
      key: 'lunar.message.source'
    }) : formattedTimestamp;
    const striped = !!(important || info || warning);
    const containerStyles = cx(styles.container, horizontalSpacing && styles.container_horizontalSpacing, verticalSpacing && styles.container_verticalSpacing, striped && styles.container_withStripe, important && styles.container_important, info && styles.container_info, warning && styles.container_warning);
    const formatedTitle = disableTitleTranslation ? React.createElement("span", {
      className: "notranslate"
    }, title) : title;

    if (loadingAuthor) {
      return React.createElement("div", {
        className: containerStyles
      }, React.createElement("div", {
        className: cx(styles.profilePhoto, styles.tableCell)
      }, React.createElement(Shimmer, {
        width: 32,
        height: 32,
        radius: "50%"
      })), React.createElement("div", {
        className: cx(styles.messageBody, styles.tableCell)
      }, React.createElement(Spacing, {
        bottom: 0.5
      }, React.createElement(Spacing, {
        right: 1,
        inline: true
      }, React.createElement(Shimmer, {
        width: 175,
        height: 14
      })), React.createElement(Text, {
        inline: true,
        small: true,
        muted: true
      }, timestamp), email && React.createElement(Shimmer, {
        height: 12,
        width: 225
      })), children), sending && React.createElement("div", {
        className: cx(styles.sendingOverlay)
      }));
    }

    let profilePhoto = null;

    if (imageSrc) {
      profilePhoto = React.createElement(ProfilePhoto, {
        imageSrc: imageSrc,
        size: 4,
        title: imageDescription || title
      });
    } else if (icon) {
      profilePhoto = React.createElement(Spacing, {
        left: 2,
        top: 0.5
      }, icon);
    }

    const avatar = imageBadgeSrc ? React.createElement("div", null, profilePhoto, React.createElement("div", {
      className: cx(styles.profileBadge)
    }, React.createElement(ProfilePhoto, {
      inline: true,
      imageSrc: imageBadgeSrc,
      size: 2,
      title: T.phrase('Profile photo badge', {}, {
        context: 'Profile photo descriptive image text within a message bubble',
        key: 'lunar.message.photoLabel'
      })
    }))) : profilePhoto;
    return React.createElement("div", {
      className: containerStyles
    }, React.createElement("div", {
      className: cx(styles.table)
    }, React.createElement("div", {
      className: cx(styles.profilePhoto, styles.tableCell)
    }, onClickImage ? React.createElement("button", {
      className: cx(styles.resetButton),
      type: "button",
      title: imageDescription || title,
      onClick: onClickImage,
      onMouseUp: removeFocusOnMouseUp
    }, avatar) : avatar), React.createElement("div", {
      className: cx(styles.messageBody, styles.tableCell)
    }, React.createElement(Spacing, {
      bottom: 0.5
    }, React.createElement("span", {
      className: cx(styles.messageTitle)
    }, onClickTitle ? React.createElement("button", {
      className: cx(styles.resetButton),
      type: "button",
      title: titleClickDescription || title,
      onClick: onClickTitle,
      onMouseUp: removeFocusOnMouseUp
    }, React.createElement(Text, {
      inline: true,
      bold: true
    }, formatedTitle)) : React.createElement(Text, {
      inline: true,
      bold: true
    }, formatedTitle)), titleTag && React.createElement("span", {
      className: cx(styles.tag)
    }, React.createElement(Text, {
      inline: true,
      micro: true,
      muted: true
    }, titleTag)), React.createElement(Text, {
      inline: true,
      small: true,
      muted: true
    }, timestamp), email && React.createElement(Text, {
      small: true,
      muted: true
    }, React.createElement(T, {
      k: "lunar.message.fromUser",
      phrase: "From: %{email}",
      email: email,
      context: "Who the message is from",
      html: true
    }))), React.createElement("div", {
      className: cx(styles.messageBodyContent)
    }, children))), sending && React.createElement("div", {
      className: cx(styles.sendingOverlay)
    }));
  }

}

_defineProperty(MessageItem, "propTypes", {
  verticalSpacing: _pt.bool,
  titleTag: _pt.string,
  titleClickDescription: _pt.string,
  title: _pt.string.isRequired,
  source: _pt.string,
  sending: _pt.bool,
  onClickTitle: _pt.func,
  onClickImage: _pt.func,
  loadingAuthor: _pt.bool,
  imageSrc: _pt.string,
  imageDescription: _pt.string,
  imageBadgeSrc: _pt.string,
  icon: _pt.node,
  horizontalSpacing: _pt.bool,
  formattedTimestamp: _pt.string.isRequired,
  email: _pt.node,
  disableTitleTranslation: _pt.bool,
  children: _pt.any.isRequired,
  important: stripeColorTypePropType,
  info: stripeColorTypePropType,
  warning: stripeColorTypePropType
});

_defineProperty(MessageItem, "defaultProps", {
  disableTitleTranslation: false,
  email: null,
  horizontalSpacing: false,
  imageBadgeSrc: '',
  imageDescription: '',
  important: false,
  info: false,
  loadingAuthor: false,
  sending: false,
  source: '',
  titleClickDescription: '',
  titleTag: '',
  verticalSpacing: false,
  warning: false
});

export default withStyles((_ref) => {
  let {
    color,
    ui,
    unit,
    pattern
  } = _ref;
  return {
    container: {
      position: 'relative',
      border: '1px solid transparent',
      borderRadius: ui.borderRadius,
      margin: 0,
      padding: 0
    },
    container_horizontalSpacing: {
      paddingLeft: unit * 2,
      paddingRight: unit * 2
    },
    container_verticalSpacing: {
      marginBottom: unit * 2,
      marginTop: unit * 2
    },
    container_withStripe: {
      borderColor: color.accent.border,
      borderWidth: "1px 1px 1px " + unit * 0.5 + "px",
      padding: unit * 2 + "px " + unit * 2 + "px " + unit * 2 + "px " + (unit * 1.5 + 1) + "px"
    },
    container_important: {
      backgroundColor: color.core.danger[0],
      borderLeftColor: color.core.danger[3]
    },
    container_info: {
      backgroundColor: color.accent.bg,
      borderLeftColor: color.core.primary[3]
    },
    container_warning: {
      backgroundColor: color.core.warning[0],
      borderLeftColor: color.core.warning[3]
    },
    table: {
      display: 'table',
      tableLayout: 'fixed',
      width: '100%'
    },
    tableCell: {
      display: 'table-cell',
      verticalAlign: 'top'
    },
    profilePhoto: {
      width: 4 * unit
    },
    profileBadge: {
      position: 'absolute',
      transform: "translate(50%, " + -unit + "px)"
    },
    messageBody: {
      paddingLeft: unit
    },
    messageBodyContent: {
      wordBreak: 'break-word'
    },
    messageTitle: {
      marginRight: unit,
      wordBreak: 'break-word'
    },
    resetButton: _extends({}, pattern.resetButton, {
      textAlign: 'left'
    }),
    sendingOverlay: {
      position: 'absolute',
      top: '0',
      left: '0',
      width: '100%',
      height: '100%',
      pointerEvents: 'all',
      backgroundColor: toRGBA(color.core.neutral[3], 50),
      zIndex: 1
    },
    tag: {
      border: ui.border,
      borderRadius: unit / 4,
      display: 'inline-block',
      lineHeight: 1,
      marginRight: unit,
      maxWidth: '100%',
      overflow: 'hidden',
      padding: "0 " + unit / 2 + "px",
      textOverflow: 'ellipsis',
      verticalAlign: 'sub',
      whiteSpace: 'nowrap'
    }
  };
})(MessageItem);