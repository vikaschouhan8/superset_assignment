import _pt from "prop-types";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import hoistNonReactStatics from 'hoist-non-react-statics';
import { fetchFromCDN } from 'emojibase';
import EmojiDataManager from './EmojiDataManager';
var loaded = new Set();
var promise = new Map();
export function resetLoaded() {
  if ("production" !== process.env.NODE_ENV) {
    loaded.clear();
    promise.clear();
  }
}

var EMOJIBASE_LATEST_VERSION = require('emojibase/package.json').version;

export default function withEmojiData(options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$alwaysRender = _options.alwaysRender,
      alwaysRender = _options$alwaysRender === void 0 ? false : _options$alwaysRender,
      _options$compact = _options.compact,
      compact = _options$compact === void 0 ? false : _options$compact,
      _options$emojis = _options.emojis,
      emojis = _options$emojis === void 0 ? [] : _options$emojis,
      _options$throwErrors = _options.throwErrors,
      throwErrors = _options$throwErrors === void 0 ? true : _options$throwErrors;
  return function withEmojiDataFactory(Component) {
    var baseName = Component.displayName || Component.name;

    var WithEmojiData = function (_React$PureComponent) {
      _inheritsLoose(WithEmojiData, _React$PureComponent);

      function WithEmojiData() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;

        _defineProperty(_assertThisInitialized(_this), "state", {
          emojis: [],
          source: {
            compact: false,
            locale: 'en',
            version: EMOJIBASE_LATEST_VERSION
          }
        });

        return _this;
      }

      var _proto = WithEmojiData.prototype;

      _proto.componentDidMount = function componentDidMount() {
        this.loadEmojis();
      };

      _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
        var _this$props = this.props,
            locale = _this$props.locale,
            version = _this$props.version;

        if (prevProps.locale !== locale || prevProps.version !== version) {
          this.loadEmojis();
        }
      };

      _proto.getDataInstance = function getDataInstance() {
        return EmojiDataManager.getInstance(this.props.locale);
      };

      _proto.setEmojis = function setEmojis(nextEmojis) {
        if (nextEmojis === void 0) {
          nextEmojis = [];
        }

        var _ref = this.props,
            locale = _ref.locale,
            version = _ref.version;
        this.setState({
          emojis: nextEmojis.length > 0 ? nextEmojis : this.getDataInstance().getData(),
          source: {
            compact: compact,
            locale: locale,
            version: version
          }
        });
      };

      _proto.loadEmojis = function loadEmojis() {
        var _this2 = this;

        var _this$props2 = this.props,
            locale = _this$props2.locale,
            version = _this$props2.version;
        var set = compact ? 'compact' : 'data';
        var key = locale + ":" + version + ":" + set;

        if (loaded.has(key) || emojis.length > 0) {
          this.setEmojis(emojis);
          return Promise.resolve();
        }

        if (promise.has(key)) {
          return promise.get(key).then(function () {
            _this2.setEmojis();
          });
        }

        var request = fetchFromCDN(locale + "/" + set + ".json", version).then(function (response) {
          loaded.add(key);

          _this2.getDataInstance().parseEmojiData(response);

          _this2.setEmojis();
        }).catch(function (error) {
          loaded.add(key);

          if (throwErrors) {
            throw error;
          }
        });
        promise.set(key, request);
        return request;
      };

      _proto.render = function render() {
        var _this$props3 = this.props,
            locale = _this$props3.locale,
            version = _this$props3.version,
            props = _objectWithoutPropertiesLoose(_this$props3, ["locale", "version"]);

        if (this.state.emojis.length === 0 && !alwaysRender) {
          return null;
        }

        return React.createElement(Component, _extends({}, props, {
          emojis: this.state.emojis,
          emojiData: this.getDataInstance(),
          emojiSource: this.state.source
        }));
      };

      return WithEmojiData;
    }(React.PureComponent);

    _defineProperty(WithEmojiData, "propTypes", {
      locale: _pt.string,
      version: _pt.string
    });

    _defineProperty(WithEmojiData, "displayName", "withEmojiData(" + baseName + ")");

    _defineProperty(WithEmojiData, "defaultProps", {
      locale: 'en',
      version: EMOJIBASE_LATEST_VERSION
    });

    hoistNonReactStatics(WithEmojiData, Component);
    return WithEmojiData;
  };
}