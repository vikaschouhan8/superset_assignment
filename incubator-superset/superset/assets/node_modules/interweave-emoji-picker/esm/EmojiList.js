import _pt from "prop-types";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import { List } from 'react-virtualized';
import chunk from 'lodash/chunk';
import withContext from './withContext';
import EmojiButton from './Emoji';
import EmojiListHeader from './EmojiListHeader';
import { GROUP_KEY_NONE } from './constants';
export var EmojiList = function (_React$PureComponent) {
  _inheritsLoose(EmojiList, _React$PureComponent);

  function EmojiList() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "state", {
      emojis: {},
      indices: {},
      rows: []
    });

    _defineProperty(_assertThisInitialized(_this), "handleRendered", function (event) {
      var startIndex = event.startIndex;
      var _this$props = _this.props,
          activeGroup = _this$props.activeGroup,
          rowCount = _this$props.rowCount,
          stickyGroupHeader = _this$props.stickyGroupHeader;
      var indices = _this.state.indices;
      var lastGroup = '';
      Object.keys(indices).some(function (group) {
        var index = indices[group];

        if (index === 0 && startIndex === 0) {
          lastGroup = group;
          return true;
        }

        if (stickyGroupHeader && index >= startIndex + 1) {
          return true;
        } else if (!stickyGroupHeader && index >= startIndex + rowCount / 2) {
          return true;
        }

        lastGroup = group;
        return false;
      });

      if (lastGroup && lastGroup !== activeGroup) {
        _this.props.onScrollGroup(lastGroup);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "renderGroupHeader", function (group, sticky) {
      if (sticky === void 0) {
        sticky = false;
      }

      var _this$props2 = _this.props,
          clearIcon = _this$props2.clearIcon,
          commonMode = _this$props2.commonMode,
          onClear = _this$props2.onClear,
          skinTonePalette = _this$props2.skinTonePalette;
      return React.createElement(EmojiListHeader, {
        clearIcon: clearIcon,
        commonMode: commonMode,
        group: group,
        onClear: onClear,
        skinTonePalette: skinTonePalette,
        sticky: sticky
      });
    });

    _defineProperty(_assertThisInitialized(_this), "renderNoResults", function () {
      var _this$props$context = _this.props.context,
          classNames = _this$props$context.classNames,
          messages = _this$props$context.messages;
      return React.createElement("div", {
        className: classNames.noResults
      }, _this.props.noResults || messages.noResults);
    });

    _defineProperty(_assertThisInitialized(_this), "renderRow", function (props) {
      var key = props.key,
          index = props.index,
          style = props.style;
      var _this$props3 = _this.props,
          activeEmoji = _this$props3.activeEmoji,
          classNames = _this$props3.context.classNames,
          emojiPadding = _this$props3.emojiPadding,
          emojiPath = _this$props3.emojiPath,
          emojiSize = _this$props3.emojiSize,
          emojiSource = _this$props3.emojiSource,
          onEnterEmoji = _this$props3.onEnterEmoji,
          onLeaveEmoji = _this$props3.onLeaveEmoji,
          onSelectEmoji = _this$props3.onSelectEmoji;
      var row = _this.state.rows[index];
      return React.createElement("div", {
        key: key,
        style: style,
        className: classNames.emojisRow
      }, Array.isArray(row) ? React.createElement("div", {
        className: classNames.emojisBody
      }, row.map(function (emoji) {
        return React.createElement(EmojiButton, {
          key: emoji.hexcode,
          active: activeEmoji ? activeEmoji.hexcode === emoji.hexcode : false,
          emoji: emoji,
          emojiPadding: emojiPadding,
          emojiPath: emojiPath,
          emojiSize: emojiSize,
          emojiSource: emojiSource,
          onEnter: onEnterEmoji,
          onLeave: onLeaveEmoji,
          onSelect: onSelectEmoji
        });
      })) : _this.renderGroupHeader(row));
    });

    return _this;
  }

  EmojiList.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, state) {
    var columnCount = _ref.columnCount,
        groupedEmojis = _ref.groupedEmojis,
        hideGroupHeaders = _ref.hideGroupHeaders;

    if (groupedEmojis === state.emojis) {
      return null;
    }

    var rows = [];
    var indices = {
      '': -1
    };
    Object.keys(groupedEmojis).forEach(function (group) {
      indices[group] = rows.length;

      if (!hideGroupHeaders) {
        rows.push(group);
      }

      rows.push.apply(rows, chunk(groupedEmojis[group].emojis, columnCount));
    });
    return {
      emojis: groupedEmojis,
      indices: indices,
      rows: rows
    };
  };

  var _proto = EmojiList.prototype;

  _proto.render = function render() {
    var _this$props4 = this.props,
        activeEmoji = _this$props4.activeEmoji,
        activeGroup = _this$props4.activeGroup,
        columnCount = _this$props4.columnCount,
        _this$props4$columnPa = _this$props4.columnPadding,
        columnPadding = _this$props4$columnPa === void 0 ? 0 : _this$props4$columnPa,
        emojiPadding = _this$props4.emojiPadding,
        emojiSize = _this$props4.emojiSize,
        groupedEmojis = _this$props4.groupedEmojis,
        rowCount = _this$props4.rowCount,
        _this$props4$rowPaddi = _this$props4.rowPadding,
        rowPadding = _this$props4$rowPaddi === void 0 ? 0 : _this$props4$rowPaddi,
        scrollToGroup = _this$props4.scrollToGroup,
        stickyGroupHeader = _this$props4.stickyGroupHeader,
        onScroll = _this$props4.onScroll;
    var classNames = this.props.context.classNames;
    var _this$state = this.state,
        indices = _this$state.indices,
        rows = _this$state.rows;
    var size = emojiSize + emojiPadding * 2;
    var rowHeight = size + rowPadding * 2;
    var columnWidth = size + columnPadding * 2;
    var renderProps = {
      activeEmoji: activeEmoji,
      groupedEmojis: groupedEmojis
    };
    return React.createElement("div", {
      className: classNames.emojis
    }, React.createElement(List, _extends({
      className: classNames.emojisList,
      height: rowHeight * rowCount,
      noRowsRenderer: this.renderNoResults,
      overscanRowCount: rowCount / 2,
      rowCount: rows.length,
      rowHeight: rowHeight,
      rowRenderer: this.renderRow,
      scrollToAlignment: "start",
      scrollToIndex: indices[scrollToGroup],
      width: columnWidth * columnCount,
      onRowsRendered: this.handleRendered,
      onScroll: onScroll
    }, renderProps)), stickyGroupHeader && activeGroup !== GROUP_KEY_NONE && this.renderGroupHeader(activeGroup, true));
  };

  return EmojiList;
}(React.PureComponent);

_defineProperty(EmojiList, "propTypes", {
  activeEmoji: _pt.oneOfType([_pt.any, _pt.oneOf([null])]),
  activeGroup: _pt.any.isRequired,
  clearIcon: _pt.node,
  columnCount: _pt.number.isRequired,
  columnPadding: _pt.number,
  commonMode: _pt.any.isRequired,
  emojiPadding: _pt.number.isRequired,
  emojiPath: _pt.any.isRequired,
  emojiSize: _pt.number.isRequired,
  emojiSource: _pt.any.isRequired,
  groupedEmojis: _pt.any.isRequired,
  hideGroupHeaders: _pt.bool.isRequired,
  noResults: _pt.node,
  onClear: _pt.func.isRequired,
  onEnterEmoji: _pt.func.isRequired,
  onLeaveEmoji: _pt.func.isRequired,
  onScroll: _pt.func.isRequired,
  onScrollGroup: _pt.func.isRequired,
  onSelectEmoji: _pt.func.isRequired,
  rowCount: _pt.number.isRequired,
  rowPadding: _pt.number,
  scrollToGroup: _pt.oneOfType([_pt.any, _pt.oneOf([''])]).isRequired,
  skinTonePalette: _pt.node,
  stickyGroupHeader: _pt.bool
});

_defineProperty(EmojiList, "defaultProps", {
  activeEmoji: null,
  clearIcon: null,
  columnPadding: 0,
  noResults: null,
  rowPadding: 0,
  skinTonePalette: null
});

export default withContext(EmojiList);